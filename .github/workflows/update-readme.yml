name: Update README Projects

on:
  schedule:
    - cron: '0 0 1 * *' # Runs on 1st of every month
  workflow_dispatch: # Manual trigger

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Fetch repos and update README
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get repos sorted by your commits and save to file
          gh api graphql -f query='
            query {
              user(login: "dimzachar") {
                repositories(first: 50, ownerAffiliations: OWNER, isFork: false, privacy: PUBLIC) {
                  nodes {
                    name
                    defaultBranchRef {
                      target {
                        ... on Commit {
                          history(author: {id: "MDQ6VXNlcjExMzAxNzczNw=="}) {
                            totalCount
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' --jq '.data.user.repositories.nodes | map(select(.defaultBranchRef != null and .defaultBranchRef.target.history.totalCount > 0)) | sort_by(.defaultBranchRef.target.history.totalCount) | reverse | .[0:12] | [.[].name]' > repos.json

          # Update projects order while preserving descriptions
          python3 << 'PYEOF'
          import json
          import re

          with open("repos.json", "r") as f:
              sorted_repos = json.load(f)

          with open("README.md", "r") as f:
              content = f.read()

          # Extract existing projects with their full lines
          pattern = r"## Current Projects\n(.*?)(?=\n## )"
          match = re.search(pattern, content, flags=re.DOTALL)
          
          if not match:
              print("Could not find Current Projects section")
              exit(1)

          existing_section = match.group(1)
          
          # Parse existing projects into a dict: repo_name -> full_line
          existing_projects = {}
          for line in existing_section.strip().split("\n"):
              # Match: - emoji **[name](url)** - description
              m = re.match(r'^- .+ \*\*\[([^\]]+)\]', line)
              if m:
                  repo_name = m.group(1)
                  existing_projects[repo_name] = line

          # Emoji and description mapping for new repos not in README
          defaults = {
              "ScholarsXP": ("ğŸ“", "Educational platform built with TypeScript"),
              "DataTalksClub-Projects": ("ğŸ“Š", "Streamlit-powered project analyzer with interactive insights"),
              "mlops-zoomcamp": ("ğŸ§ ", "MLOps Zoomcamp coursework"),
              "mlzoomcamp": ("ğŸ ", "ML Zoomcamp coursework"),
              "xGoals-mlops": ("âš½", "End-to-End MLOps Pipeline for Football Analytics (xG)"),
              "llm_zoomcamp": ("ğŸ“š", "LLM Zoomcamp coursework"),
              "langgraph-multiagent-rag": ("ğŸ¤–", "Multi-agent RAG orchestration with LangGraph"),
              "Parthenon-RAG-Game": ("ğŸ®", "2D pixel-art RPG with AI-powered NPCs"),
              "bq-langgraph-analysis-agent": ("ğŸ“ˆ", "BigQuery analysis agent â€“ SQL meets AI"),
              "DataTalksClub-Timestamp-Issues": ("â±ï¸", "Automates YouTube transcript timestamps for GitHub issues"),
              "de-zoomcamp": ("ğŸ—ï¸", "Data Engineering Zoomcamp â€“ pipelines, warehouses, orchestration"),
              "fastapi_energy_efficiency_buildings": ("âš¡", "FastAPI app for building energy efficiency prediction"),
          }

          def get_emoji(name):
              if name in defaults:
                  return defaults[name][0]
              name_lower = name.lower()
              if any(x in name_lower for x in ["ml", "ai", "llm", "agent", "rag"]):
                  return "ğŸ¤–"
              if any(x in name_lower for x in ["data", "analytics", "pipeline"]):
                  return "ğŸ“Š"
              if any(x in name_lower for x in ["api", "fastapi", "backend"]):
                  return "âš¡"
              if any(x in name_lower for x in ["game", "play"]):
                  return "ğŸ®"
              if any(x in name_lower for x in ["zoomcamp", "course"]):
                  return "ğŸ“š"
              return "ğŸ“¦"

          # Build new projects section, preserving existing lines
          lines = ["## Current Projects\n"]
          for repo_name in sorted_repos:
              if repo_name in existing_projects:
                  # Keep existing line (preserves description)
                  lines.append(existing_projects[repo_name])
              elif repo_name in defaults:
                  # Use default
                  emoji, desc = defaults[repo_name]
                  lines.append(f'- {emoji} **[{repo_name}](https://github.com/dimzachar/{repo_name})** - {desc}')
              else:
                  # New repo - auto-detect emoji, empty description
                  emoji = get_emoji(repo_name)
                  lines.append(f'- {emoji} **[{repo_name}](https://github.com/dimzachar/{repo_name})** - ')

          projects_section = "\n".join(lines)

          # Replace in content
          content = re.sub(pattern, projects_section + "\n\n", content, flags=re.DOTALL)

          with open("README.md", "w") as f:
              f.write(content)

          print("README updated! Order changed, descriptions preserved.")
          PYEOF

          rm repos.json

      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          git diff --quiet && git diff --staged --quiet || git commit -m "chore: update projects order by commit count"
          git push
